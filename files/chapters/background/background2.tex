\chapter{Background}
When designing the new Autograder front-end, it was necessary to develop other parts of the system for emulating dummy-data for the project. One of the most conventional ways of doing this is to create a database that stores the dummy-data, and have a server serve the front-end with that data. The system works in many ways as the fully functional Autograder, with predefined protocols for communications so that the new front-end can be implemented and deployed with a relatively small amount of effort. Making these protocols require us to both think about the current needs and future needs. Even though the system is currently up and running, many new ways of communicating with the new front-end is planned and will be implemented in the new system. It is however, no small task to create these sub-systems. We will go though some of the technologies we are using in this chapter.

\section{Front-end}
One of the goals of the new Autograder front-end is to create a better and faster experience for the end-user. This means reflecting on the old design and expierence, and revisit the technologies and code written in the old Autograder front-end. Design choices described in later chapters decided what kind of technology we could use on the new site. This section describes the libraries and frameworks used.

\subsection{Bootstrap}
Hyper text markup language, or HTML, is a markup language used to build websites. Content is placed inside of different document object models, or DOM-elements. The different boxes of content is styled using a cascading style sheet, or CSS. Making the websites and layouts can take a lot of time. To simplify this, there are many open source project that supply off-the-shelf elements. Since we have experience with Bootstrap from earlier projects, it was decided that we would use Bootstrap 3.0 for the new front-end. The framework is in it's third iteration (soon 4th with Bootstrap 4.0 Alpha being shipped early 2016). The framework comes with build in styling, so the job of the designer (or rather lack of designers) is made easier. Compared to vanilla coding in HTML and CSS, the framework can remove countless of hours of coding, and the results look clean and functional.

\subsection{ReactJS}
\\Since the front-end communicates with a server, data will come in asynchronously and must trigger a re-render of the DOM-elements if the data that comes in is new. This process of updating and binding data can be implemented using libraries such as ReactJS. React is an open source JavaScript library designed and maintained by Facebook \worry{ref here}. The framework provides a view for data rendered as HTML, and maintains a state that can change depending on the data that comes from the server. This removes a lot of overhead programming that the developers usually have to think about. If the data in the server changes, the change are reflected on the page in real-time. Say for example that the users rights are changed from Student to Teacher. The front-end will have to reflect that change, and show data relevant for a teacher. With React, this change can be made without having to update the page manually. One of React's strongest sides are real-time updating of the DOM, therefore, it is a very good library for Autograder front-end. 


\\The choice between ReactJS and AngularJS (the other big JavaScript-library in the industry) is really based on preference. The component based pipeline that React offers is very appealing when the website will recycle a lot of the same elements. The new front-end can be compared to a single-page-application, where the different pages are loaded in without refreshing the page. Normally this requires a lot of loading and unloading of elements, and ReactJS already has implemented. 

\\ReactJS uses Virtual DOM to run its Tree Diff algorythm and figures out what parts of the DOM should be rendered, this enables quick re-rendering of only relevant for the change components.

\begin{figure}[h]
\centering
\scalebox{0.5}{\scalefont{1.8}{\input{./graphs/reactdiffdiagramthin.tex}}}
\caption{Graph of how React uses Virtual DOM to patch the DOM}
\end{figure}

As of April 2016, ReactJS is in version 15.01. A new version of ReactJS has been announced, but it is not deployment ready as of now. React is written in JSX, a simplified JavaScript language with XML-layout. The JSX-file is transformed to pure JavaScript. In addition, the XML-attributes are transformed into arguments. Simplified syntax removes a lot of typing, and regular HTML DOM-elements are predefined in React. This means that most HTML-elements can be directly typed in the JSX without having to import or define new elements. Elements such as \emph{input}, \emph{div}, \emph{button} and many more are there out of the box.

\section{Back-end}
To be able to make the front-end without using real datasets, it was necessary to create a functional server that can get data from the storage solution and serve it to the front-end. The original Autograder already use Go, short for Go language, as the programming language for the back-end. Go is very fast when it comes to web-servers. Making a webserver requires just a few lines of code, and handles multiple connections in go-routines, which is similar to threads. Therefore, it is not a hard choice when selecting the programming language of the back-end. The web-servers job is to be the link between the data stored in the system and the front-end. As mentioned, predefined protocols for communication, such as data structures created with JSON (JavaScript Object Notation) is used to communicate with the front-end. Sending packages with content that the front-end can decode and handle in a predefined way. Consequently, the back-end can be written in many programming languages without effecting the front-end or storage. \\Logic for roles, such as admin, teacher and student are also managed in the back-end. The logic behind the login page and authentication with Github is also managed back-end in the web-server. The Go language is a general-purpose language designed as a system programming language. It focuses heavily on concurrency and garbage-collection, and is therefore perfect for web-servers.

\section{Storage solution}
Even though the scope of the assignment is the front-end, a storage solution was necessary. The original system uses key-value-store, which is great for storing data which can be found using a key or index. The key-value-store is really fast when searching for keys, but lack the relational structure that Autograder needs. The new Autograder need a system that can store relations between roles and courses. Therefore, the solution that is used is a relational database. The database is filled with dummy-data from the beginning, so that the front-end and server can work with data. The dummy-data will represent real data, and look like the data that the real front-end will produce. The data can simply be replaced by real data later on if the new front-end is implemented in the existing Autograder-environment. \\The data is stored in the relational database, and can be retrieved using MySQL. The data retrieved using string-based commands, such as \emph{"GET * FROM user\_database"}. This is a very practical way of getting data, and combining this with Go can help make the back-end modular. A modular back-end can simplify the process of expanding the system in the future.