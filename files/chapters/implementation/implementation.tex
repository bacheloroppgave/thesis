\chapter{Implementation}
Implementation of the design and architecture is not always straightforward. Especially when working on new unfamiliar frameworks. A lot of work has been done in frameworks such as Angular with MVP, other frameworsk would usually use MVP, or slight alteration of it. This was not the case with React.js and Flux which was chose for this application solution.
\section{Dataflow}
\subsection{React.js}
React focuses on fast rendering of selected components, withouth the need for refreshing the page. Of course it doesnt magically works out of the box, one still needs to design the logick and data transfer in such a way to enable this real-time re-rendering of the components. As discuissed in section \ref{sec:flux} \emph{Flux}, in this application flux architecture was used. This architecture is only a way to write your program, so that there is some structure to follow, and do specific things the same way. An exaple would be handling the user input from a specific component. React has a way to communicate between components, and in the beginnig there were attempts to utilize this in orther to send data between different components, like user input automatically updates some field. It is very simple to achieve in react, although the way to go about it, is not by sending data directly thgrough, and between the components, rather have an external logic that could listen to one components change and update another. It becomes clear when the application grows, it is almost impossible to keep track of all the states and wher the data travells. This leads to the next point - architecture Flux.


\begin{lstlisting}

function getStateFromStores() {
  return {
    query: '',
    students: StudentSelectorStore.getAllStudents(),
  };
};

var StudentSelector = React.createClass({

  getInitialState: function() {
    StudentSelectorAPI.getAllStudents();
    return getStateFromStores();
  },

  componentDidMount: function() {
    StudentSelectorStore.addChangeListener(this._onChange);
  },

  componentWillunmount: function() {
    StudentSelectorStore.addChangeListener(this._onChange);
  },

\end{lstlisting}

\begin{lstlisting}
  render: function() {
    var students = this.state.students;
    var self = this;
    return(
      <div>
        <StudentSelectorSearch
        query={self.state.query}
        searchFor={self._searchFor}
        />
          {
            students.map( function(student) {
              return(
                  <StudentSelectorElement
                  key={student.studentNumber}
                  student={student}
                  handleClick={self._onAddToGroup.bind(self, student)}
                  />
              );
            })
          }
          </ListGroup>
      </div>
    );
  },

  _onChange: function() {
    this.setState(getStateFromStores());
  },

  _onAddToGroup: function(student) {
    StudentSelectorActionCreators.addStudentToGroup(student);
  },

  _searchFor: function(event) {
    this.setState({query: event.target.value})
    StudentSelectorActionCreators.searchForStudent(event.target.value);
  }
});

\end{lstlisting}


\subsection{Flux}

\section{Websockets}

\section{Backend}

